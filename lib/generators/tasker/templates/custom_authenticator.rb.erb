# frozen_string_literal: true

# Custom authenticator for <%= class_name %>
# Generated by: rails generate tasker:authenticator <%= file_name %> --type=custom
#
# This authenticator template provides a starting point for implementing
# custom authentication logic in your Tasker application.
#
# Configuration example:
#   Tasker.configuration do |config|
#     config.auth do |auth|
#       auth.strategy = :custom
#       auth.options = {
#         authenticator_class: '<%= class_name %>Authenticator',
#         user_class: '<%= user_model_class %>'
#         # Add your custom options here
#       }
#     end
#   end

class <%= class_name %>Authenticator
  include Tasker::Authentication::Interface

  def initialize(options = {})
    @user_class = options[:user_class] || '<%= user_model_class %>'
    @options = options
  end

  # Required: Authenticate the request, raise exception if fails
  def authenticate!(controller)
    user = current_user(controller)
    unless user
      raise Tasker::Authentication::AuthenticationError,
            'Authentication failed. Please provide valid credentials.'
    end
    true
  end

  # Required: Get the current authenticated user
  def current_user(controller)
    return @current_user if defined?(@current_user)

    @current_user = begin
      # TODO: Implement your user lookup logic here
      # Examples:
      #   - Check session for user ID
      #   - Extract token from headers
      #   - Use existing Rails authentication
      #   - Custom authentication scheme

      # Example session-based lookup:
      # user_id = controller.session[:user_id]
      # return nil unless user_id
      # user_model.find_by(id: user_id)

      # Example header-based lookup:
      # token = controller.request.headers['Authorization']
      # return nil unless token
      # find_user_by_token(token)

      # Placeholder - replace with your logic
      nil
    rescue StandardError => e
      Rails.logger.error "Authentication error in <%= class_name %>Authenticator: #{e.message}"
      nil
    end
  end

  # Optional: Check if user is authenticated (uses current_user by default)
  def authenticated?(controller)
    current_user(controller).present?
  end

  # Optional: Configuration validation
  def validate_configuration(options = {})
    errors = []

    # Validate user class
    user_class = options[:user_class] || '<%= user_model_class %>'
    begin
      user_class.constantize
    rescue NameError
      errors << "User class '#{user_class}' not found"
    end

    # TODO: Add your custom validation logic here
    # Examples:
    #   - Required configuration options
    #   - External service dependencies
    #   - Security settings validation

    errors
  end

  private

  attr_reader :options, :user_class

  def user_model
    @user_model ||= @user_class.constantize
  end

  # TODO: Add your private helper methods here
  # Examples:
  #   def extract_token(request)
  #   def find_user_by_token(token)
  #   def validate_credentials(credentials)
end
