# frozen_string_literal: true

# Devise authenticator for <%= class_name %>
# Generated by: rails generate tasker:authenticator <%= file_name %> --type=devise
#
# This authenticator integrates with Devise authentication system.
# Uses Devise's built-in authentication methods and scopes.
#
# Configuration example:
#   Tasker.configuration do |config|
#     config.auth do |auth|
#       auth.strategy = :custom
#       auth.options = {
#         authenticator_class: '<%= class_name %>Authenticator',
#         scope: :user
#       }
#     end
#   end

class <%= class_name %>Authenticator
  include Tasker::Authentication::Interface

  def initialize(options = {})
    @scope = options[:scope] || :user
    @failure_app = options[:failure_app]
    @options = options
  end

  # Required: Authenticate the request, raise exception if fails
  def authenticate!(controller)
    # Use Devise's built-in authentication
    result = controller.send("authenticate_#{@scope}!")

    # Devise authenticate_*! methods return true on success or redirect/halt on failure
    # If we reach here, authentication was successful
    result
  rescue StandardError => e
    # Devise authentication failed
    raise Tasker::Authentication::AuthenticationError,
          "Devise authentication failed: #{e.message}"
  end

  # Required: Get the current authenticated user
  def current_user(controller)
    # Use Devise's current_user helper
    controller.send("current_#{@scope}")
  rescue StandardError => e
    Rails.logger.error "Error getting current #{@scope}: #{e.message}"
    nil
  end

  # Optional: Check if user is authenticated
  def authenticated?(controller)
    # Use Devise's user_signed_in? helper if available
    signed_in_method = "#{@scope}_signed_in?"

    if controller.respond_to?(signed_in_method)
      controller.send(signed_in_method)
    else
      # Fallback to checking current_user presence
      current_user(controller).present?
    end
  end

  # Optional: Configuration validation
  def validate_configuration(options = {})
    errors = []

    # Check if Devise is available
    unless defined?(Devise)
      errors << 'Devise gem is required for DeviseAuthenticator'
    end

    # Validate scope
    scope = options[:scope] || :user
    unless scope.is_a?(Symbol)
      errors << 'Devise scope must be a symbol'
    end

    # Check if scope is configured in Devise
    if defined?(Devise) && Devise.mappings[scope].nil?
      errors << "Devise scope '#{scope}' is not configured. Available scopes: #{Devise.mappings.keys.join(', ')}"
    end

    errors
  end

  private

  attr_reader :scope, :failure_app, :options

  # Helper method to get the user model class for the scope
  def user_model_class
    return nil unless defined?(Devise)

    mapping = Devise.mappings[@scope]
    mapping&.class_name&.constantize
  rescue StandardError
    nil
  end
end
