# frozen_string_literal: true

# JWT authenticator for <%= class_name %>
# Generated by: rails generate tasker:authenticator <%= file_name %> --type=jwt
#
# This authenticator implements JWT-based authentication with security best practices.
# Supports both Bearer token and raw token formats in Authorization headers.
#
# Configuration example:
#   Tasker::Configuration.configuration do |config|
#     config.auth do |auth|
#       auth.strategy = :custom
#       auth.options = {
#         authenticator_class: '<%= class_name %>Authenticator',
#         secret: Rails.application.credentials.jwt_secret,
#         algorithm: 'HS256',
#         header_name: 'Authorization',
#         user_class: '<%= user_model_class %>'
#       }
#     end
#   end

class <%= class_name %>Authenticator
  include Tasker::Authentication::Interface

  def initialize(options = {})
    @secret = options[:secret] || Rails.application.secret_key_base
    @algorithm = options[:algorithm] || 'HS256'
    @header_name = options[:header_name] || 'Authorization'
    @user_class = options[:user_class] || '<%= user_model_class %>'
  end

  # Required: Authenticate the request, raise exception if fails
  def authenticate!(controller)
    user = current_user(controller)
    unless user
      raise Tasker::Authentication::AuthenticationError,
            'Invalid or missing JWT token'
    end
    true
  end

  # Required: Get the current authenticated user
  def current_user(controller)
    return @current_user if defined?(@current_user)

    @current_user = begin
      token = extract_token(controller.request)
      return nil unless token

      payload = decode_token(token)
      return nil unless payload

      find_user(payload)
    rescue JWT::DecodeError, StandardError => e
      Rails.logger.debug "JWT authentication failed: #{e.message}"
      nil
    end
  end

  # Optional: Configuration validation with security best practices
  def validate_configuration(options = {})
    errors = []

    # Validate JWT secret
    secret = options[:secret]
    if secret.blank?
      errors << 'JWT secret is required'
    elsif secret.length < 32
      errors << 'JWT secret should be at least 32 characters for security'
    end

    # Validate algorithm
    algorithm = options[:algorithm] || 'HS256'
    allowed_algorithms = %w[HS256 HS384 HS512 RS256 RS384 RS512 ES256 ES384 ES512]
    unless allowed_algorithms.include?(algorithm)
      errors << "JWT algorithm must be one of: #{allowed_algorithms.join(', ')}"
    end

    # Validate user class
    user_class = options[:user_class] || '<%= user_model_class %>'
    begin
      user_class.constantize
    rescue NameError
      errors << "User class '#{user_class}' not found"
    end

    errors
  end

  # Helper method for generating test tokens (useful for testing)
  def self.generate_test_token(payload, secret: nil, algorithm: 'HS256')
    secret ||= Rails.application.secret_key_base

    # Add standard JWT claims
    now = Time.current.to_i
    full_payload = {
      'iat' => now,
      'exp' => now + 1.hour.to_i
    }.merge(payload.stringify_keys)

    JWT.encode(full_payload, secret, algorithm)
  end

  private

  attr_reader :secret, :algorithm, :header_name, :user_class

  def extract_token(request)
    header = request.headers[@header_name]
    return nil unless header.present?

    # Support both "Bearer <token>" and raw token formats
    header.start_with?('Bearer ') ? header.sub(/^Bearer /, '') : header
  end

  def decode_token(token)
    payload, _header = JWT.decode(
      token,
      @secret,
      true, # verify signature
      {
        algorithm: @algorithm,
        verify_expiration: true,
        verify_iat: true
      }
    )
    payload
  rescue JWT::ExpiredSignature, JWT::InvalidIatError
    # These are expected errors for expired tokens
    nil
  end

  def find_user(payload)
    # Support both 'user_id' and 'sub' (subject) claims
    user_id = payload['user_id'] || payload['sub']
    return nil unless user_id

    user_model = @user_class.constantize
    user_model.find_by(id: user_id)
  rescue ActiveRecord::RecordNotFound, NoMethodError
    nil
  end
end
