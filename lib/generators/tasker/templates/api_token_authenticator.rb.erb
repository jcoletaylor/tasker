# frozen_string_literal: true

# API Token authenticator for <%= class_name %>
# Generated by: rails generate tasker:authenticator <%= file_name %> --type=api_token
#
# This authenticator implements API token-based authentication.
# Expects tokens to be passed in request headers and looks up users by token.
#
# Configuration example:
#   Tasker::Configuration.configuration do |config|
#     config.auth do |auth|
#       auth.strategy = :custom
#       auth.options = {
#         authenticator_class: '<%= class_name %>Authenticator',
#         header_name: 'X-API-Token',
#         user_class: '<%= user_model_class %>',
#         token_field: 'api_token'
#       }
#     end
#   end

class <%= class_name %>Authenticator
  include Tasker::Authentication::Interface

  def initialize(options = {})
    @header_name = options[:header_name] || 'X-API-Token'
    @user_class = options[:user_class] || '<%= user_model_class %>'
    @token_field = options[:token_field] || 'api_token'
    @options = options
  end

  # Required: Authenticate the request, raise exception if fails
  def authenticate!(controller)
    user = current_user(controller)
    unless user
      raise Tasker::Authentication::AuthenticationError,
            'Invalid or missing API token'
    end
    true
  end

  # Required: Get the current authenticated user
  def current_user(controller)
    return @current_user if defined?(@current_user)

    @current_user = begin
      token = extract_token(controller.request)
      return nil unless token

      find_user_by_token(token)
    rescue StandardError => e
      Rails.logger.debug "API token authentication failed: #{e.message}"
      nil
    end
  end

  # Optional: Configuration validation
  def validate_configuration(options = {})
    errors = []

    # Validate user class
    user_class = options[:user_class] || '<%= user_model_class %>'
    begin
      model = user_class.constantize

      # Check if the token field exists
      token_field = options[:token_field] || 'api_token'
      unless model.column_names.include?(token_field.to_s)
        errors << "User model '#{user_class}' does not have '#{token_field}' column"
      end
    rescue NameError
      errors << "User class '#{user_class}' not found"
    end

    # Validate header name
    header_name = options[:header_name]
    if header_name.present? && !header_name.is_a?(String)
      errors << 'Header name must be a string'
    end

    errors
  end

  private

  attr_reader :header_name, :user_class, :token_field, :options

  def extract_token(request)
    # Try configured header first
    token = request.headers[@header_name]
    return token if token.present?

    # Fallback to Authorization header with Bearer format
    auth_header = request.headers['Authorization']
    return nil unless auth_header.present?

    # Support "Bearer <token>" format
    auth_header.start_with?('Bearer ') ? auth_header.sub(/^Bearer /, '') : auth_header
  end

  def find_user_by_token(token)
    return nil if token.blank?

    user_model = @user_class.constantize
    user_model.find_by(@token_field => token)
  rescue ActiveRecord::RecordNotFound, NoMethodError
    nil
  end

  def user_model
    @user_model ||= @user_class.constantize
  end
end
