# frozen_string_literal: true

<% if @module_namespace %>
module <%= @module_namespace %>
<% end %>
  module <%= @task_name %>
    module StepHandler
      # Step name constants matching those in YAML
      FETCH_DATA = 'fetch_data'.freeze
      PROCESS_DATA = 'process_data'.freeze
      COMPLETE_TASK = 'complete_task'.freeze

      class FetchDataStepHandler < Tasker::StepHandler::Api
        def call(task, _sequence, _step)
          input_id = task.context['input_id']
          connection.get("/data/#{input_id}")
        end

        def handle(_task, _sequence, step)
          super
          step.results = get_from_results(step.results, 'data')
        end

        private

        def get_from_results(results, key)
          results&.dig('data', key) || {}
        end
      end

      class ProcessDataStepHandler
        def handle(_task, sequence, step)
          data = get_data_from_previous_step(sequence)
          processed_data = process_data(data)

          step.results = { processed_data: processed_data }
        end

        private

        def get_data_from_previous_step(sequence)
          step = sequence.find_step_by_name(<%= @module_namespace ? "#{@module_namespace}::" : '' %><%= @task_name %>::StepHandler::FETCH_DATA)
          if step.nil? || step.results.empty?
            raise "Required data not found in sequence"
          end

          step.results
        end

        def process_data(data)
          # Process the data as needed for your specific task
          # This is a placeholder implementation
          {
            processed: true,
            original_data_id: data['id'],
            timestamp: Time.now.iso8601
          }
        end
      end

      class CompleteTaskStepHandler
        def handle(_task, sequence, step)
          processed_data = get_processed_data(sequence)

          # Implement your task completion logic here
          result = {
            task_completed: true,
            data_id: processed_data[:original_data_id],
            completion_timestamp: Time.now.iso8601
          }

          step.results = result
        end

        private

        def get_processed_data(sequence)
          step = sequence.find_step_by_name(<%= @module_namespace ? "#{@module_namespace}::" : '' %><%= @task_name %>::StepHandler::PROCESS_DATA)
          if step.nil? || step.results.empty?
            raise "Processed data not found in sequence"
          end

          step.results[:processed_data]
        end
      end
    end
  end
<% if @module_namespace %>
end
<% end %>
