# frozen_string_literal: true

# Generated by Tasker Demo Application Builder
# Execution Configuration Examples for: <%= @app_name %>
# Generated at: <%= Time.now.strftime("%Y%m%dT%H%M%S%z") %>

# ========================================
# TASKER EXECUTION CONFIGURATION EXAMPLES
# ========================================
#
# This file demonstrates various execution configuration scenarios
# for different deployment environments and workload characteristics.
# Copy and adapt the examples that match your use case.

# =====================================
# DEVELOPMENT ENVIRONMENT CONFIGURATION
# =====================================
# Conservative settings for local development with limited resources

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Conservative concurrency for development
#     exec.min_concurrent_steps = 2           # Lower minimum for resource constraints
#     exec.max_concurrent_steps_limit = 6     # Moderate maximum for development
#     exec.concurrency_cache_duration = 60    # Longer cache for stability
#
#     # Shorter timeouts for fast feedback during development
#     exec.batch_timeout_base_seconds = 20    # Shorter base timeout
#     exec.batch_timeout_per_step_seconds = 5 # Standard per-step timeout
#     exec.max_batch_timeout_seconds = 60     # Lower maximum for quick failure detection
#   end
# end

# =====================================
# PRODUCTION ENVIRONMENT CONFIGURATION
# =====================================
# High-performance settings for production deployment

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Aggressive concurrency for production performance
#     exec.min_concurrent_steps = 5           # Higher minimum for consistent throughput
#     exec.max_concurrent_steps_limit = 25    # High maximum for enterprise scale
#     exec.concurrency_cache_duration = 15    # Shorter cache for responsiveness
#
#     # Longer timeouts for reliability in production
#     exec.batch_timeout_base_seconds = 45    # Longer base for reliability
#     exec.batch_timeout_per_step_seconds = 8 # More time for complex operations
#     exec.max_batch_timeout_seconds = 300    # 5 minutes for long-running workflows
#   end
# end

# ==========================================
# HIGH-PERFORMANCE SYSTEM CONFIGURATION
# ==========================================
# For systems with large database connection pools and high throughput needs

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Maximum concurrency for high-performance systems
#     exec.min_concurrent_steps = 10          # High minimum for sustained throughput
#     exec.max_concurrent_steps_limit = 50    # Very high maximum (ensure DB pool can handle)
#     exec.concurrency_cache_duration = 10    # Very responsive to load changes
#
#     # Extended timeouts for complex workflows
#     exec.batch_timeout_base_seconds = 60    # Longer base for complex operations
#     exec.batch_timeout_per_step_seconds = 10 # More time per step
#     exec.max_batch_timeout_seconds = 600    # 10 minutes for very long workflows
#   end
# end

# ====================================
# API-HEAVY WORKFLOW CONFIGURATION
# ====================================
# For workflows that make many external API calls

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Moderate concurrency to avoid overwhelming external APIs
#     exec.min_concurrent_steps = 3           # Standard minimum
#     exec.max_concurrent_steps_limit = 8     # Limited to avoid API rate limits
#     exec.concurrency_cache_duration = 45    # Stable for consistent API load
#
#     # Extended timeouts for external API calls
#     exec.batch_timeout_base_seconds = 60    # Longer base for API latency
#     exec.batch_timeout_per_step_seconds = 15 # Much more time for API calls
#     exec.max_batch_timeout_seconds = 300    # 5 minutes for slow APIs
#   end
# end

# =========================================
# DATABASE-INTENSIVE CONFIGURATION
# =========================================
# For workflows with heavy database operations

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Respect database connection limits
#     exec.min_concurrent_steps = 3           # Standard minimum
#     exec.max_concurrent_steps_limit = 8     # Limited by database connection pool
#     exec.concurrency_cache_duration = 45    # Stable database load
#
#     # Standard timeouts for database operations
#     exec.batch_timeout_base_seconds = 30    # Standard base timeout
#     exec.batch_timeout_per_step_seconds = 8 # More time for complex queries
#     exec.max_batch_timeout_seconds = 180    # 3 minutes for complex operations
#   end
# end

# ==================================
# MIXED WORKLOAD CONFIGURATION
# ==================================
# Balanced settings for varied workflow types

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Balanced concurrency for mixed workloads
#     exec.min_concurrent_steps = 4           # Higher minimum for consistency
#     exec.max_concurrent_steps_limit = 16    # Moderate maximum for flexibility
#     exec.concurrency_cache_duration = 20    # Balance responsiveness and stability
#
#     # Balanced timeouts for varied operations
#     exec.batch_timeout_base_seconds = 35    # Slightly higher base
#     exec.batch_timeout_per_step_seconds = 7 # Balanced per-step timeout
#     exec.max_batch_timeout_seconds = 200    # Reasonable maximum for mixed workloads
#   end
# end

# =======================================
# TESTING ENVIRONMENT CONFIGURATION
# =======================================
# Fast execution for automated testing

# Tasker.configure do |config|
#   config.execution do |exec|
#     # Minimal concurrency for test reliability
#     exec.min_concurrent_steps = 1           # Single-threaded for test predictability
#     exec.max_concurrent_steps_limit = 3     # Very low maximum for test isolation
#     exec.concurrency_cache_duration = 5     # Short cache for test isolation
#
#     # Short timeouts for fast test execution
#     exec.batch_timeout_base_seconds = 10    # Quick failure detection
#     exec.batch_timeout_per_step_seconds = 2 # Minimal per-step timeout
#     exec.max_batch_timeout_seconds = 30     # Quick test completion
#   end
# end

# ========================================
# MONITORING AND VALIDATION
# ========================================
# Examples of how to monitor configuration effectiveness

# # Access current configuration
# current_config = Tasker.configuration.execution
#
# # Monitor dynamic concurrency decisions
# Rails.logger.info "Current max concurrency: #{step_executor.max_concurrent_steps}"
#
# # Check timeout calculations for different batch sizes
# [1, 5, 10, 20].each do |batch_size|
#   timeout = current_config.calculate_batch_timeout(batch_size)
#   Rails.logger.info "Batch size #{batch_size}: #{timeout}s timeout"
# end
#
# # Monitor GC trigger decisions
# batch_size = 10
# duration = 45
# should_gc = current_config.should_trigger_gc?(batch_size, duration)
# Rails.logger.info "Batch size #{batch_size}, duration #{duration}s: GC trigger = #{should_gc}"

# ========================================
# CONFIGURATION VALIDATION
# ========================================
# Validate your configuration before deployment

# # Manual validation with detailed errors
# config = Tasker.configuration.execution
# errors = config.validate_concurrency_bounds + config.validate_timeout_configuration
#
# if errors.any?
#   Rails.logger.error "Execution configuration errors: #{errors.join(', ')}"
#   raise "Invalid Tasker execution configuration"
# else
#   Rails.logger.info "Tasker execution configuration validated successfully"
# end

# ========================================
# PERFORMANCE TUNING GUIDELINES
# ========================================
#
# 1. START WITH DEFAULTS
#    - Use default values initially and measure performance
#    - Only adjust after identifying specific bottlenecks
#
# 2. MONITOR KEY METRICS
#    - Database connection pool utilization
#    - Step execution times and throughput
#    - Memory usage patterns
#    - Error rates and timeout frequency
#
# 3. ADJUST BASED ON PATTERNS
#    - High connection pressure → Reduce max_concurrent_steps_limit
#    - Frequent timeouts → Increase timeout settings
#    - Slow response to load changes → Reduce concurrency_cache_duration
#    - Memory pressure → Consider GC settings (not configurable)
#
# 4. ENVIRONMENT-SPECIFIC TUNING
#    - Development: Conservative settings for stability
#    - Staging: Production-like settings for realistic testing
#    - Production: Performance-optimized settings
#    - Testing: Minimal concurrency for predictability
#
# 5. WORKLOAD-SPECIFIC OPTIMIZATION
#    - API-heavy: Longer timeouts, moderate concurrency
#    - Database-intensive: Respect connection limits
#    - Mixed workloads: Balanced settings with monitoring
#
# For detailed tuning guidance, see: docs/EXECUTION_CONFIGURATION.md
