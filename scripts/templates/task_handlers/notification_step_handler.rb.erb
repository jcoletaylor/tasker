# frozen_string_literal: true

# Generated by Tasker Demo Application Builder
# Task: <%= task_name %>
# Step: <%= step_name %>
# Generated at: <%= Time.current.iso8601 %>

module <%= namespace.classify %>
  module StepHandlers
    class <%= step_name.classify %>StepHandler < Tasker::StepHandler::Base
      def process(_task, _sequence, step)
        log_structured(
          :info,
          "Processing <%= step_name %> notification step",
          correlation_id: step.task.task_id,
          step_name: step.name,
          task: "<%= task_name %>"
        )

        # Get input data from previous steps
        input_data = extract_input_data(step)

        # Send notifications based on step type
        <% case step_type -%>
        <% when 'email_notification' -%>
        result = send_email_notification(input_data)
        <% when 'sms_notification' -%>
        result = send_sms_notification(input_data)
        <% when 'webhook_notification' -%>
        result = send_webhook_notification(input_data)
        <% when 'slack_notification' -%>
        result = send_slack_notification(input_data)
        <% when 'order_confirmation' -%>
        result = send_order_confirmation(input_data)
        <% when 'inventory_alert' -%>
        result = send_inventory_alert(input_data)
        <% else -%>
        result = send_generic_notification(input_data)
        <% end -%>

        log_structured(
          :info,
          "Successfully processed <%= step_name %> notification step",
          correlation_id: step.task.task_id,
          notifications_sent: result[:notifications_sent] || 0,
          notification_type: result[:notification_type],
          processing_duration: step.duration
        )

        result

      rescue StandardError => e
        log_structured(
          :error,
          "Error processing <%= step_name %> notification step",
          error: e.message,
          backtrace: e.backtrace.first(5),
          correlation_id: step.task.task_id
        )
        raise
      end

      private

      def extract_input_data(step)
        # Extract data from previous step results
        previous_steps = step.task.workflow_steps.where('sequence < ?', step.sequence).completed

        input_data = {}
        previous_steps.each do |prev_step|
          input_data[prev_step.name] = prev_step.results if prev_step.results.present?
        end

        # Also include task context
        input_data['context'] = step.task.context
        input_data
      end

      <% case step_type -%>
      <% when 'email_notification' -%>
      def send_email_notification(input_data)
        # Send email notification
        # In a real application, this would use ActionMailer or email service

        user_data = extract_user_data(input_data)
        email_content = build_email_content(input_data)

        # Simulate email sending
        # In real app: UserMailer.notification_email(user_data, email_content).deliver_now

        notification_id = "email_#{SecureRandom.hex(8)}"

        log_structured(
          :info,
          "Email notification sent",
          correlation_id: step.task.task_id,
          notification_id: notification_id,
          recipient: user_data[:email],
          subject: email_content[:subject]
        )

        {
          notification_type: 'email',
          notification_id: notification_id,
          recipient: user_data[:email],
          subject: email_content[:subject],
          notifications_sent: 1,
          sent_at: Time.current.iso8601,
          delivery_status: 'sent'
        }
      end

      def build_email_content(input_data)
        # Build email content based on workflow context
        case step.task.name
        when 'order_processing'
          order_data = input_data['create_order'] || {}
          {
            subject: "Order Confirmation - #{order_data['order_id']}",
            body: "Your order has been confirmed. Total: $#{order_data['total_amount']}"
          }
        when 'user_onboarding'
          user_data = input_data['validate_registration_data'] || {}
          {
            subject: "Welcome to our platform!",
            body: "Welcome #{user_data['firstName']}! Your account has been created."
          }
        else
          {
            subject: "Notification from <%= task_name %>",
            body: "This is an automated notification from your workflow."
          }
        end
      end

      <% when 'sms_notification' -%>
      def send_sms_notification(input_data)
        # Send SMS notification
        # In a real application, this would use Twilio, AWS SNS, etc.

        user_data = extract_user_data(input_data)
        sms_content = build_sms_content(input_data)

        # Simulate SMS sending
        # In real app: SmsService.send_message(user_data[:phone], sms_content[:message])

        notification_id = "sms_#{SecureRandom.hex(8)}"

        log_structured(
          :info,
          "SMS notification sent",
          correlation_id: step.task.task_id,
          notification_id: notification_id,
          recipient: user_data[:phone],
          message_length: sms_content[:message].length
        )

        {
          notification_type: 'sms',
          notification_id: notification_id,
          recipient: user_data[:phone],
          message: sms_content[:message],
          notifications_sent: 1,
          sent_at: Time.current.iso8601,
          delivery_status: 'sent'
        }
      end

      def build_sms_content(input_data)
        # Build SMS content (keep it short)
        case step.task.name
        when 'order_processing'
          order_data = input_data['create_order'] || {}
          {
            message: "Order #{order_data['order_id']} confirmed. Total: $#{order_data['total_amount']}"
          }
        else
          {
            message: "Notification from <%= task_name %> workflow."
          }
        end
      end

      <% when 'webhook_notification' -%>
      def send_webhook_notification(input_data)
        # Send webhook notification
        # In a real application, this would make HTTP requests to external systems

        webhook_url = ENV['WEBHOOK_URL'] || 'https://webhook.example.com/notifications'
        payload = build_webhook_payload(input_data)

        # Simulate webhook sending
        # In real app: HTTP.post(webhook_url, json: payload)

        notification_id = "webhook_#{SecureRandom.hex(8)}"

        log_structured(
          :info,
          "Webhook notification sent",
          correlation_id: step.task.task_id,
          notification_id: notification_id,
          webhook_url: webhook_url,
          payload_size: payload.to_json.bytesize
        )

        {
          notification_type: 'webhook',
          notification_id: notification_id,
          webhook_url: webhook_url,
          payload: payload,
          notifications_sent: 1,
          sent_at: Time.current.iso8601,
          delivery_status: 'sent'
        }
      end

      def build_webhook_payload(input_data)
        {
          event_type: '<%= step_name %>',
          task_id: step.task.task_id,
          task_name: step.task.name,
          timestamp: Time.current.iso8601,
          data: input_data
        }
      end

      <% when 'slack_notification' -%>
      def send_slack_notification(input_data)
        # Send Slack notification
        # In a real application, this would use Slack API or webhooks

        slack_channel = ENV['SLACK_CHANNEL'] || '#notifications'
        message = build_slack_message(input_data)

        # Simulate Slack message sending
        # In real app: SlackService.send_message(slack_channel, message)

        notification_id = "slack_#{SecureRandom.hex(8)}"

        log_structured(
          :info,
          "Slack notification sent",
          correlation_id: step.task.task_id,
          notification_id: notification_id,
          channel: slack_channel,
          message_length: message.length
        )

        {
          notification_type: 'slack',
          notification_id: notification_id,
          channel: slack_channel,
          message: message,
          notifications_sent: 1,
          sent_at: Time.current.iso8601,
          delivery_status: 'sent'
        }
      end

      def build_slack_message(input_data)
        case step.task.name
        when 'order_processing'
          order_data = input_data['create_order'] || {}
          ":shopping_cart: New order confirmed: #{order_data['order_id']} ($#{order_data['total_amount']})"
        when 'stock_management'
          stock_data = input_data['identify_low_stock'] || {}
          ":warning: Low stock alert: #{stock_data['low_stock_count']} products need reordering"
        else
          ":bell: Notification from <%= task_name %> workflow completed"
        end
      end

      <% when 'order_confirmation' -%>
      def send_order_confirmation(input_data)
        # Send comprehensive order confirmation
        order_data = input_data['create_order'] || {}
        pricing_data = input_data['calculate_pricing'] || {}
        cart_data = input_data['validate_cart'] || {}

        # Send both email and SMS if available
        notifications_sent = 0
        notifications = []

        # Email confirmation
        if user_email = extract_user_email(input_data)
          email_result = send_order_email(order_data, pricing_data, cart_data, user_email)
          notifications << email_result
          notifications_sent += 1
        end

        # SMS confirmation
        if user_phone = extract_user_phone(input_data)
          sms_result = send_order_sms(order_data, user_phone)
          notifications << sms_result
          notifications_sent += 1
        end

        {
          notification_type: 'order_confirmation',
          order_id: order_data['order_id'],
          notifications: notifications,
          notifications_sent: notifications_sent,
          sent_at: Time.current.iso8601
        }
      end

      <% when 'inventory_alert' -%>
      def send_inventory_alert(input_data)
        # Send inventory management alerts
        stock_data = input_data['identify_low_stock'] || {}
        low_stock_products = stock_data['low_stock_products'] || []

        # Send alert to inventory managers
        alert_data = {
          alert_type: 'low_stock',
          products_count: low_stock_products.length,
          products: low_stock_products.map { |p| { id: p['id'], title: p['title'], stock: p['stock'] } },
          threshold: input_data.dig('context', 'threshold'),
          generated_at: Time.current.iso8601
        }

        # Simulate sending to inventory management system
        # In real app: InventoryService.send_alert(alert_data)

        notification_id = "inventory_alert_#{SecureRandom.hex(8)}"

        {
          notification_type: 'inventory_alert',
          notification_id: notification_id,
          alert_data: alert_data,
          notifications_sent: 1,
          sent_at: Time.current.iso8601
        }
      end

      <% else -%>
      def send_generic_notification(input_data)
        # Generic notification template
        notification_id = "notification_#{SecureRandom.hex(8)}"

        # Simulate notification sending
        log_structured(
          :info,
          "Generic notification sent",
          correlation_id: step.task.task_id,
          notification_id: notification_id,
          step_name: '<%= step_name %>'
        )

        {
          notification_type: 'generic',
          notification_id: notification_id,
          step_name: '<%= step_name %>',
          input_data_keys: input_data.keys,
          notifications_sent: 1,
          sent_at: Time.current.iso8601
        }
      end
      <% end -%>

      # Helper methods
      def extract_user_data(input_data)
        # Extract user information from various sources
        user_data = {}

        # Try to get user data from different steps
        if registration_data = input_data['validate_registration_data']
          user_data.merge!(registration_data)
        end

        if cart_data = input_data['validate_cart']
          user_data[:user_id] = cart_data['user_id']
        end

        # Add context data
        if context_data = input_data['context']
          user_data.merge!(context_data)
        end

        user_data
      end

      def extract_user_email(input_data)
        user_data = extract_user_data(input_data)
        user_data[:email] || user_data['email']
      end

      def extract_user_phone(input_data)
        user_data = extract_user_data(input_data)
        user_data[:phone] || user_data['phone']
      end

      def send_order_email(order_data, pricing_data, cart_data, email)
        # Detailed order confirmation email
        {
          type: 'email',
          recipient: email,
          subject: "Order Confirmation - #{order_data['order_id']}",
          content: {
            order_id: order_data['order_id'],
            items: cart_data['products'],
            pricing: pricing_data,
            total: order_data['total_amount']
          }
        }
      end

      def send_order_sms(order_data, phone)
        # Brief order confirmation SMS
        {
          type: 'sms',
          recipient: phone,
          message: "Order #{order_data['order_id']} confirmed. Total: $#{order_data['total_amount']}"
        }
      end
    end
  end
end
