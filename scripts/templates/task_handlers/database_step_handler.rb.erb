# frozen_string_literal: true

# Generated by Tasker Demo Application Builder
# Task: <%= task_name %>
# Step: <%= step_name %>
# Generated at: <%= Time.current.iso8601 %>

module <%= namespace.classify %>
  module StepHandlers
    class <%= step_name.classify %>StepHandler < Tasker::StepHandler::Base
      def process(_task, _sequence, step)
        log_structured(
          :info,
          "Processing <%= step_name %> database step",
          correlation_id: step.task.task_id,
          step_name: step.name,
          task: "<%= task_name %>"
        )

        # Get input data from previous steps
        input_data = extract_input_data(step)

        # Perform database operations based on step type
        <% case step_type -%>
        <% when 'user_lookup' -%>
        result = perform_user_lookup(input_data)
        <% when 'order_creation' -%>
        result = create_order_record(input_data)
        <% when 'inventory_update' -%>
        result = update_inventory_levels(input_data)
        <% when 'audit_log' -%>
        result = create_audit_log(input_data)
        <% else -%>
        result = perform_database_operation(input_data)
        <% end -%>

        log_structured(
          :info,
          "Successfully processed <%= step_name %> database step",
          correlation_id: step.task.task_id,
          records_affected: result[:records_affected] || 0,
          processing_duration: step.duration
        )

        result

      rescue StandardError => e
        log_structured(
          :error,
          "Error processing <%= step_name %> database step",
          error: e.message,
          backtrace: e.backtrace.first(5),
          correlation_id: step.task.task_id
        )
        raise
      end

      private

      def extract_input_data(step)
        # Extract data from previous step results
        previous_steps = step.task.workflow_steps.where('sequence < ?', step.sequence).completed

        input_data = {}
        previous_steps.each do |prev_step|
          input_data[prev_step.name] = prev_step.results if prev_step.results.present?
        end

        # Also include task context
        input_data['context'] = step.task.context
        input_data
      end

      <% case step_type -%>
      <% when 'user_lookup' -%>
      def perform_user_lookup(input_data)
        # Simulate user lookup in local database
        # In a real application, this would query your User model
        user_data = input_data.dig('validate_registration_data') || {}

        # Simulate database query
        existing_user = find_user_by_email_or_username(
          user_data['email'],
          user_data['username']
        )

        {
          user_found: existing_user.present?,
          user_id: existing_user&.dig('id'),
          conflict_type: determine_conflict_type(existing_user, user_data),
          records_affected: existing_user ? 1 : 0,
          queried_at: Time.current.iso8601
        }
      end

      def find_user_by_email_or_username(email, username)
        # Simulate database lookup
        # In real app: User.find_by(email: email) || User.find_by(username: username)

        # For demo purposes, simulate some existing users
        existing_users = [
          { 'id' => 1, 'email' => 'admin@example.com', 'username' => 'admin' },
          { 'id' => 2, 'email' => 'test@example.com', 'username' => 'testuser' }
        ]

        existing_users.find do |user|
          user['email'] == email || user['username'] == username
        end
      end

      def determine_conflict_type(existing_user, new_user_data)
        return nil unless existing_user

        if existing_user['email'] == new_user_data['email']
          'email_conflict'
        elsif existing_user['username'] == new_user_data['username']
          'username_conflict'
        else
          'unknown_conflict'
        end
      end

      <% when 'order_creation' -%>
      def create_order_record(input_data)
        # Create order record in local database
        # In a real application, this would create an Order model record

        cart_data = input_data['validate_cart'] || {}
        pricing_data = input_data['calculate_pricing'] || {}

        order_record = {
          id: generate_order_id,
          user_id: cart_data['user_id'],
          cart_id: cart_data['cart_id'],
          items: cart_data['products'] || [],
          subtotal: pricing_data['subtotal'] || 0,
          tax_amount: pricing_data['tax_amount'] || 0,
          shipping_cost: pricing_data['shipping_cost'] || 0,
          total_amount: pricing_data['final_total'] || 0,
          status: 'pending',
          created_at: Time.current.iso8601,
          updated_at: Time.current.iso8601
        }

        # Simulate database insert
        # In real app: Order.create!(order_record)

        {
          order_id: order_record[:id],
          status: 'created',
          total_amount: order_record[:total_amount],
          records_affected: 1,
          created_at: order_record[:created_at]
        }
      end

      def generate_order_id
        "ORD#{Time.current.strftime('%Y%m%d')}#{SecureRandom.random_number(10000).to_s.rjust(4, '0')}"
      end

      <% when 'inventory_update' -%>
      def update_inventory_levels(input_data)
        # Update inventory levels in local database
        # In a real application, this would update Product/Inventory models

        stock_analysis = input_data['identify_low_stock'] || {}
        low_stock_products = stock_analysis['low_stock_products'] || []

        updates_made = 0
        updated_products = []

        low_stock_products.each do |product|
          # Simulate inventory update
          new_stock_level = product['stock'] + calculate_reorder_quantity(product)

          # In real app: Product.find(product['id']).update!(stock: new_stock_level)

          updated_products << {
            product_id: product['id'],
            previous_stock: product['stock'],
            new_stock: new_stock_level,
            reorder_quantity: calculate_reorder_quantity(product)
          }

          updates_made += 1
        end

        {
          products_updated: updates_made,
          updated_products: updated_products,
          records_affected: updates_made,
          updated_at: Time.current.iso8601
        }
      end

      def calculate_reorder_quantity(product)
        # Simple reorder logic - in real app this would be more sophisticated
        base_reorder = 50

        case product['category']&.downcase
        when 'groceries'
          base_reorder * 2
        when 'furniture'
          base_reorder / 2
        else
          base_reorder
        end
      end

      <% when 'audit_log' -%>
      def create_audit_log(input_data)
        # Create audit log entries for the workflow
        # In a real application, this would create AuditLog model records

        audit_entries = []

        # Log each completed step
        step.task.workflow_steps.completed.each do |completed_step|
          audit_entry = {
            id: SecureRandom.uuid,
            task_id: step.task.task_id,
            step_id: completed_step.workflow_step_id,
            step_name: completed_step.name,
            action: 'step_completed',
            data: completed_step.results,
            created_at: completed_step.updated_at.iso8601
          }

          audit_entries << audit_entry
        end

        # In real app: AuditLog.insert_all(audit_entries)

        {
          audit_entries_created: audit_entries.length,
          entries: audit_entries,
          records_affected: audit_entries.length,
          logged_at: Time.current.iso8601
        }
      end

      <% else -%>
      def perform_database_operation(input_data)
        # Generic database operation template
        # Customize based on specific business requirements

        {
          operation_type: '<%= step_name %>',
          input_data_keys: input_data.keys,
          records_affected: 1,
          processed_at: Time.current.iso8601
        }
      end
      <% end -%>
    end
  end
end
