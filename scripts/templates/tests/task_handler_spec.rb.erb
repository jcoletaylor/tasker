# frozen_string_literal: true

# Generated by Tasker Demo Application Builder
# Test for: <%= namespace.classify %>::<%= task_name.classify %>Task
# Generated at: <%= Time.now.strftime("%Y%m%dT%H%M%S%z") %>

require 'rails_helper'

RSpec.describe <%= namespace.classify %>::<%= task_name.classify %>Task, type: :task_handler do
  describe 'task registration' do
    it 'registers the task handler correctly' do
      handler = Tasker::Registry::HandlerFactory.instance.find(
        dependent_system: '<%= namespace %>',
        handler_name: '<%= task_name %>'
      )

      expect(handler).to eq(<%= namespace.classify %>::<%= task_name.classify %>Task)
    end
  end

  describe 'step template definitions' do
    let(:task_handler) { <%= namespace.classify %>::<%= task_name.classify %>Task.new }

    it 'defines the correct number of steps' do
      step_templates = task_handler.step_templates
      expect(step_templates.length).to eq(<%= steps.length %>)
    end

    <% steps.each do |step| %>
    it 'defines <%= step[:name] %> step template' do
      step_template = task_handler.step_templates.find { |t| t.name == '<%= step[:name] %>' }

      expect(step_template).to be_present
      expect(step_template.description).to eq('<%= step[:description] %>')
      expect(step_template.handler_class).to eq(<%= namespace.classify %>::StepHandlers::<%= step[:name].classify %>StepHandler)
      <% if step[:depends_on_step] %>
      expect(step_template.depends_on_step).to eq('<%= step[:depends_on_step] %>')
      <% end %>
    end

    <% end %>
  end

  describe 'context validation schema' do
    let(:task_handler) { <%= namespace.classify %>::<%= task_name.classify %>Task.new }

    it 'defines required context fields' do
      schema = task_handler.schema
      required_fields = <%= required_context_fields.inspect %>

      expect(schema[:required]).to match_array(required_fields)
    end

    <% context_schema.each do |field, config| %>
    it 'defines <%= field %> field schema' do
      schema = task_handler.schema
      field_schema = schema[:properties][:<%= field %>]

      expect(field_schema).to eq(<%= config.inspect %>)
    end

    <% end %>
  end

  describe 'task execution' do
    let!(:task_namespace) { create(:task_namespace, namespace_name: '<%= namespace %>') }
    let!(:named_task) do
      create(:named_task,
        name: '<%= task_name %>',
        task_namespace: task_namespace,
        handler: '<%= namespace.classify %>::<%= task_name.classify %>Task'
      )
    end

    let(:valid_context) do
      {
        <% required_context_fields.each do |field| %>
        '<%= field %>' => 'test_value',
        <% end %>
      }
    end

    it 'creates a task with valid context' do
      task = Tasker::Task.create!(
        named_task: named_task,
        context: valid_context
      )

      expect(task).to be_persisted
      expect(task.context).to include(valid_context)
    end

    it 'creates the correct workflow steps' do
      task = Tasker::Task.create!(
        named_task: named_task,
        context: valid_context
      )

      # Trigger step creation
      Tasker::Orchestration::StepBuilder.build_steps_for_task(task)

      expect(task.workflow_steps.count).to eq(<%= steps.length %>)

      <% steps.each_with_index do |step, index| %>
      step_<%= index + 1 %> = task.workflow_steps.find_by(name: '<%= step[:name] %>')
      expect(step_<%= index + 1 %>).to be_present
      expect(step_<%= index + 1 %>.sequence).to eq(<%= index + 1 %>)
      <% end %>
    end

    it 'sets up step dependencies correctly' do
      task = Tasker::Task.create!(
        named_task: named_task,
        context: valid_context
      )

      Tasker::Orchestration::StepBuilder.build_steps_for_task(task)

      <% steps.each do |step| %>
      <% if step[:depends_on_step] %>
      <%= step[:name] %>_step = task.workflow_steps.find_by(name: '<%= step[:name] %>')
      <%= step[:depends_on_step] %>_step = task.workflow_steps.find_by(name: '<%= step[:depends_on_step] %>')

      dependency = Tasker::WorkflowStepEdge.find_by(
        from_step: <%= step[:depends_on_step] %>_step,
        to_step: <%= step[:name] %>_step
      )

      expect(dependency).to be_present
      <% end %>
      <% end %>
    end
  end

  <% if has_annotations %>
  describe 'annotations' do
    let!(:task_namespace) { create(:task_namespace, namespace_name: '<%= namespace %>') }
    let!(:named_task) do
      create(:named_task,
        name: '<%= task_name %>',
        task_namespace: task_namespace,
        handler: '<%= namespace.classify %>::<%= task_name.classify %>Task'
      )
    end

    let(:task) do
      create(:task,
        named_task: named_task,
        context: {
          <% required_context_fields.each do |field| %>
          '<%= field %>' => 'test_value',
          <% end %>
        }
      )
    end

    it 'creates annotations for completed steps' do
      # Create completed steps
      steps = <%= steps.length %>.times.map do |i|
        create(:workflow_step,
          task: task,
          name: "step_#{i + 1}",
          sequence: i + 1,
          status: Tasker::Constants::WorkflowStepStatuses::COMPLETE,
          results: { test: 'data' }
        )
      end

      task_handler = <%= namespace.classify %>::<%= task_name.classify %>Task.new
      task_handler.update_annotations(task, nil, steps)

      expect(Tasker::TaskAnnotation.where(task: task).count).to eq(steps.length)

      annotation = Tasker::TaskAnnotation.where(task: task).first
      expect(annotation.annotation['task_name']).to eq('<%= task_name %>')
      expect(annotation.annotation['namespace']).to eq('<%= namespace %>')
    end
  end
  <% end %>
end
