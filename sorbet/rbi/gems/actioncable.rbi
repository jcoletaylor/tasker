# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/actioncable/all/actioncable.rbi
#
# actioncable-6.1.4.1

module ActionCable
  def self.gem_version; end
  def self.server; end
  def self.version; end
  def server; end
  extend ActiveSupport::Autoload
end
module ActionCable::VERSION
end
module ActionCable::Helpers
end
module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag; end
end
class ActionCable::Engine < Rails::Engine
  def self.__callbacks; end
end
module ActionCable::Server
  extend ActiveSupport::Autoload
end
module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: nil); end
  def broadcaster_for(broadcasting, coder: nil); end
end
class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end
  def broadcasting; end
  def coder; end
  def initialize(server, broadcasting, coder:); end
  def server; end
end
module ActionCable::Server::Connections
  def add_connection(connection); end
  def connections; end
  def open_connections_statistics; end
  def remove_connection(connection); end
  def setup_heartbeat_timer; end
end
class ActionCable::Server::Configuration
  def allow_same_origin_as_host; end
  def allow_same_origin_as_host=(arg0); end
  def allowed_request_origins; end
  def allowed_request_origins=(arg0); end
  def cable; end
  def cable=(arg0); end
  def connection_class; end
  def connection_class=(arg0); end
  def disable_request_forgery_protection; end
  def disable_request_forgery_protection=(arg0); end
  def initialize; end
  def log_tags; end
  def log_tags=(arg0); end
  def logger; end
  def logger=(arg0); end
  def mount_path; end
  def mount_path=(arg0); end
  def pubsub_adapter; end
  def url; end
  def url=(arg0); end
  def worker_pool_size; end
  def worker_pool_size=(arg0); end
end
class ActionCable::Server::Worker
  def __callbacks; end
  def __callbacks?; end
  def _run_work_callbacks(&block); end
  def _work_callbacks; end
  def async_exec(receiver, *args, connection:, &block); end
  def async_invoke(receiver, method, *args, connection: nil, &block); end
  def connection; end
  def connection=(obj); end
  def executor; end
  def halt; end
  def initialize(max_size: nil); end
  def invoke(receiver, method, *args, connection:, &block); end
  def logger; end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._work_callbacks; end
  def self._work_callbacks=(value); end
  def self.connection; end
  def self.connection=(obj); end
  def stopping?; end
  def work(connection); end
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  include ActionCable::Server::Worker::ActiveRecordConnectionManagement
  include ActiveSupport::Callbacks
end
module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections; end
  extend ActiveSupport::Concern
end
module ActionCable::Channel
  extend ActiveSupport::Autoload
end
module ActionCable::Channel::Callbacks
  extend ActiveSupport::Concern
  include ActiveSupport::Callbacks
end
module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end
  def after_unsubscribe(*methods, &block); end
  def before_subscribe(*methods, &block); end
  def before_unsubscribe(*methods, &block); end
  def on_subscribe(*methods, &block); end
  def on_unsubscribe(*methods, &block); end
end
module ActionCable::Channel::PeriodicTimers
  def active_periodic_timers; end
  def start_periodic_timer(callback, every:); end
  def start_periodic_timers; end
  def stop_periodic_timers; end
  extend ActiveSupport::Concern
end
module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name = nil, every:, &block); end
end
module ActionCable::Channel::Streams
  def default_stream_handler(broadcasting, coder:); end
  def identity_handler; end
  def pubsub(**, &&); end
  def stop_all_streams; end
  def stop_stream_for(model); end
  def stop_stream_from(broadcasting); end
  def stream_decoder(handler = nil, coder:); end
  def stream_for(model, callback = nil, coder: nil, &block); end
  def stream_from(broadcasting, callback = nil, coder: nil, &block); end
  def stream_handler(broadcasting, user_handler, coder: nil); end
  def stream_or_reject_for(record); end
  def stream_transmitter(handler = nil, broadcasting:); end
  def streams; end
  def worker_pool_stream_handler(broadcasting, user_handler, coder: nil); end
  extend ActiveSupport::Concern
end
module ActionCable::Channel::Naming
  def channel_name(**, &&); end
  extend ActiveSupport::Concern
end
module ActionCable::Channel::Naming::ClassMethods
  def channel_name; end
end
module ActionCable::Channel::Broadcasting
  def broadcast_to(**, &&); end
  def broadcasting_for(**, &&); end
  extend ActiveSupport::Concern
end
module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end
  def broadcasting_for(model); end
  def serialize_broadcasting(object); end
end
class ActionCable::Channel::Base
  def __callbacks; end
  def __callbacks?; end
  def _run_subscribe_callbacks(&block); end
  def _run_unsubscribe_callbacks(&block); end
  def _subscribe_callbacks; end
  def _unsubscribe_callbacks; end
  def action_signature(action, data); end
  def connection; end
  def defer_subscription_confirmation!; end
  def defer_subscription_confirmation?; end
  def delegate_connection_identifiers; end
  def dispatch_action(action, data); end
  def ensure_confirmation_sent; end
  def extract_action(data); end
  def identifier; end
  def initialize(connection, identifier, params = nil); end
  def logger(**, &&); end
  def params; end
  def perform_action(data); end
  def periodic_timers=(arg0); end
  def processable_action?(action); end
  def reject; end
  def reject_subscription; end
  def rescue_handlers; end
  def rescue_handlers=(arg0); end
  def rescue_handlers?; end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._subscribe_callbacks; end
  def self._subscribe_callbacks=(value); end
  def self._unsubscribe_callbacks; end
  def self._unsubscribe_callbacks=(value); end
  def self.action_methods; end
  def self.clear_action_methods!; end
  def self.method_added(name); end
  def self.periodic_timers; end
  def self.periodic_timers=(value); end
  def self.periodic_timers?; end
  def self.rescue_handlers; end
  def self.rescue_handlers=(value); end
  def self.rescue_handlers?; end
  def subscribe_to_channel; end
  def subscribed; end
  def subscription_confirmation_sent?; end
  def subscription_rejected?; end
  def transmit(data, via: nil); end
  def transmit_subscription_confirmation; end
  def transmit_subscription_rejection; end
  def unsubscribe_from_channel; end
  def unsubscribed; end
  extend ActionCable::Channel::Broadcasting::ClassMethods
  extend ActionCable::Channel::Callbacks::ClassMethods
  extend ActionCable::Channel::Naming::ClassMethods
  extend ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  extend ActiveSupport::Rescuable::ClassMethods
  include ActionCable::Channel::Broadcasting
  include ActionCable::Channel::Callbacks
  include ActionCable::Channel::Naming
  include ActionCable::Channel::PeriodicTimers
  include ActionCable::Channel::Streams
  include ActiveSupport::Callbacks
  include ActiveSupport::Rescuable
end
class ActionCable::Server::Base
  def call(env); end
  def config; end
  def connection_identifiers; end
  def disconnect(identifiers); end
  def event_loop; end
  def initialize(config: nil); end
  def logger(**, &&); end
  def mutex; end
  def pubsub; end
  def remote_connections; end
  def restart; end
  def self.config; end
  def self.config=(val); end
  def self.logger; end
  def worker_pool; end
  include ActionCable::Server::Broadcasting
  include ActionCable::Server::Connections
end
class ActiveSupport::TestCase < Minitest::Test
  include ActiveSupport::CurrentAttributes::TestHelper
end
class ActionController::Base < ActionController::Metal
  def _serialization_scope; end
  def _serialization_scope=(arg0); end
  def _serialization_scope?; end
  def namespace_for_serializer=(arg0); end
  def self._serialization_scope; end
  def self._serialization_scope=(value); end
  def self._serialization_scope?; end
  extend ActionController::Railties::Helpers
  extend ActionController::Serialization::ClassMethods
  extend ActiveRecord::Railties::ControllerRuntime::ClassMethods
  extend Anonymous_Module_25
  include ActionController::Renderers
  include ActionController::Serialization
  include ActionDispatch::Routing::RouteSet::MountedHelpers
  include ActionDispatch::Routing::UrlFor
  include ActiveRecord::Railties::ControllerRuntime
end
module Anonymous_Module_25
  def inherited(klass); end
end
class ActionController::API < ActionController::Metal
  def _serialization_scope; end
  def _serialization_scope=(arg0); end
  def _serialization_scope?; end
  def namespace_for_serializer=(arg0); end
  def self._serialization_scope; end
  def self._serialization_scope=(value); end
  def self._serialization_scope?; end
  extend ActionController::Railties::Helpers
  extend ActionController::Serialization::ClassMethods
  extend ActiveRecord::Railties::ControllerRuntime::ClassMethods
  extend Anonymous_Module_26
  include ActionController::Renderers
  include ActionController::Serialization
  include ActionDispatch::Routing::RouteSet::MountedHelpers
  include ActionDispatch::Routing::UrlFor
  include ActiveRecord::Railties::ControllerRuntime
end
module Anonymous_Module_26
  def inherited(klass); end
end
class ActiveSupport::Executor < ActiveSupport::ExecutionWrapper
  def self.__callbacks; end
end
class ActiveRecord::Base
  def attachment_reflections; end
  def attachment_reflections?; end
  extend ActionText::Attribute::ClassMethods
  extend ActiveStorage::Attached::Model::ClassMethods
  extend ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods
  include ActionText::Attribute
  include ActiveStorage::Attached::Model
  include ActiveStorage::Reflection::ActiveRecordExtensions
  include GlobalID::Identification
end
class ActionView::Railtie < Rails::Engine
  def self.__callbacks; end
end
class Sidekiq::Rails < Rails::Engine
  def self.__callbacks; end
end
class Tasker::Engine < Rails::Engine
  def self.__callbacks; end
end
class ActiveStorage::Engine < Rails::Engine
  def self.__callbacks; end
end
class ActionMailbox::Engine < Rails::Engine
  def self.__callbacks; end
end
class ActionText::Engine < Rails::Engine
  def self.__callbacks; end
end
class Dummy::Application < Rails::Application
  def self.__callbacks; end
end
module ActionView::RoutingUrlFor
  def default_url_options=(val); end
  def self.default_url_options=(val); end
  include ActionDispatch::Routing::UrlFor
  include ActionDispatch::Routing::UrlFor
end
class ActiveJob::Base
  def self.__synchronized_sidekiq_options_hash; end
  def self.__synchronized_sidekiq_retries_exhausted_block; end
  def self.__synchronized_sidekiq_retry_in_block; end
  def self.sidekiq_options_hash; end
  def self.sidekiq_options_hash=(val); end
  def self.sidekiq_retries_exhausted_block; end
  def self.sidekiq_retries_exhausted_block=(val); end
  def self.sidekiq_retry_in_block; end
  def self.sidekiq_retry_in_block=(val); end
  def sidekiq_options_hash; end
  def sidekiq_options_hash=(arg0); end
  def sidekiq_retries_exhausted_block; end
  def sidekiq_retries_exhausted_block=(arg0); end
  def sidekiq_retry_in_block; end
  def sidekiq_retry_in_block=(arg0); end
  extend Sidekiq::Worker::Options::ClassMethods
  include Sidekiq::Worker::Options
end
module Anonymous_Module_20
  include ActionText::ContentHelper
  include ActionText::TagHelper
end
module ActionText
end
module ActionText::ContentHelper
  def allowed_attributes; end
  def allowed_attributes=(val); end
  def allowed_tags; end
  def allowed_tags=(val); end
  def render_action_text_attachments(content); end
  def render_action_text_content(content); end
  def sanitize_action_text_content(content); end
  def sanitizer; end
  def sanitizer=(val); end
  def scrubber; end
  def scrubber=(val); end
  def self.allowed_attributes; end
  def self.allowed_attributes=(val); end
  def self.allowed_tags; end
  def self.allowed_tags=(val); end
  def self.sanitizer; end
  def self.sanitizer=(val); end
  def self.scrubber; end
  def self.scrubber=(val); end
end
module ActionText::TagHelper
  def rich_text_area_tag(name, value = nil, options = nil); end
  def self.id; end
  def self.id=(val); end
end
module ActionView::Helpers
end
class ActionView::Helpers::Tags::ActionText < ActionView::Helpers::Tags::Base
  def dom_id(**, &&); end
  def editable_value; end
  def render; end
  include ActionView::Helpers::Tags::Placeholderable
end
module ActionView::Helpers::FormHelper
  def rich_text_area(object_name, method, options = nil); end
end
class ActionView::Helpers::FormBuilder
  def rich_text_area(method, options = nil); end
end
module ActionController::Base::HelperMethods
  include Anonymous_Module_20
end
class Object < BasicObject
  def load(*arg0); end
  def require(path); end
end
module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app; end
  def _tasker; end
  def main_app; end
  def tasker; end
end
module ActionCable::Connection
  extend ActiveSupport::Autoload
end
module ActionCable::Connection::Identification
  def connection_gid(ids); end
  def connection_identifier; end
  extend ActiveSupport::Concern
end
module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end
module ActionCable::Connection::InternalChannel
  def internal_channel; end
  def process_internal_message(message); end
  def subscribe_to_internal_channel; end
  def unsubscribe_from_internal_channel; end
  extend ActiveSupport::Concern
end
module ActionCable::Connection::Authorization
  def reject_unauthorized_connection; end
end
class ActionCable::Connection::Authorization::UnauthorizedError < StandardError
end
class ActionCable::Connection::Base
  def allow_request_origin?; end
  def beat; end
  def close(reason: nil, reconnect: nil); end
  def cookies; end
  def decode(websocket_message); end
  def dispatch_websocket_message(websocket_message); end
  def encode(cable_message); end
  def env; end
  def event_loop(**, &&); end
  def finished_request_message; end
  def handle_close; end
  def handle_open; end
  def identifiers; end
  def identifiers=(arg0); end
  def identifiers?; end
  def initialize(server, env, coder: nil); end
  def invalid_request_message; end
  def logger; end
  def message_buffer; end
  def new_tagged_logger; end
  def on_close(reason, code); end
  def on_error(message); end
  def on_message(message); end
  def on_open; end
  def process; end
  def protocol; end
  def pubsub(**, &&); end
  def receive(websocket_message); end
  def request; end
  def rescue_handlers; end
  def rescue_handlers=(arg0); end
  def rescue_handlers?; end
  def respond_to_invalid_request; end
  def respond_to_successful_request; end
  def self.identifiers; end
  def self.identifiers=(value); end
  def self.identifiers?; end
  def self.rescue_handlers; end
  def self.rescue_handlers=(value); end
  def self.rescue_handlers?; end
  def send_async(method, *arguments); end
  def send_welcome_message; end
  def server; end
  def started_request_message; end
  def statistics; end
  def subscriptions; end
  def successful_request_message; end
  def transmit(cable_message); end
  def websocket; end
  def worker_pool; end
  extend ActionCable::Connection::Identification::ClassMethods
  extend ActiveSupport::Rescuable::ClassMethods
  include ActionCable::Connection::Authorization
  include ActionCable::Connection::Identification
  include ActionCable::Connection::InternalChannel
  include ActiveSupport::Rescuable
end
